/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#define IRQ_TIM2 28
#define IRQ_I2C1 31

uint32_t  *NVIC_IPR_base = (uint32_t  *)0xE000E400; //Interrupt priority register
uint32_t  *NVIC_ISPR_base = (uint32_t  *)0XE000E200; //Interrupt set-pending register
uint32_t  *NVIC_ISER_base =(uint32_t  *) 0xE000E100;//Interrupt set_enable register


void config_priority(uint8_t IRQ_number,uint8_t IRQ_Priority)
{
	/*step1 :identify the interrupt priority register for the specific IRQ
	 * each 32 bit register of IPR can hold iqr priority for 4 irq
	 * To identify the specific IPR used*/
	uint8_t IPRx = IRQ_number/ 4; //example :if IRQ 6 -> 6/4 = 1 so IPR1 has to be used

	/*step 2: Identify the specific irq address
	 * if IPRx is 1  IPRbase address + 1 will point to the IPR1*/
	uint32_t *IPR = NVIC_IPR_base + IPRx ;

	/*step3: identify the specific 8 bits for the mentioned IRQ
	 * IRQnumber%4 => part of the bit for specific irq
	 * exmaple if irq is 6 6%4 => 2 indicating the second 8 bit is for the irq6
	 *
	 * multiply with 8 to get bit number :example 2x8 = 16 (start bit for specific IRQ*/
	uint8_t strbitpos_of_irq =(IRQ_number% 4)*8;

	/*Step4: input the IRQ priority in the IPR register*/
	*IPR &= ~(0xFF << strbitpos_of_irq);//clearing the contents of the 8 bits
	*IPR  |= (IRQ_Priority << strbitpos_of_irq);

}

void set_Pending_register_bit(uint8_t IRQ_number)
{
	uint32_t *ISPR = NVIC_ISPR_base + (uint8_t)(IRQ_number / 32);

	    *ISPR |= (1<<(IRQ_number % 32));
}

void Enable_Interrupt_register_bit(uint8_t IRQ_number)
{
	uint32_t *ISER = NVIC_ISER_base + (uint8_t)(IRQ_number / 32);

	    *ISER |= (1<<(IRQ_number % 32));
}

int main(void)
{
	//step 1: give priority using interrupt priority register
    config_priority(IRQ_TIM2,0x80);

    config_priority(IRQ_I2C1,0x70);
	//step2 : pending level bit

    set_Pending_register_bit(IRQ_TIM2);

	//step 3 : enable interrupt using ISER register
    Enable_Interrupt_register_bit(IRQ_I2C1);
    Enable_Interrupt_register_bit(IRQ_TIM2);



    /* Loop forever */
	for(;;);
}

//ISR

void TIM2_IRQHandler(void)
{
	printf("Timer2_interrupt\n");
	set_Pending_register_bit(IRQ_I2C1);
	while(1);
}

void I2C1_EV_IRQHandler(void)
{
	printf("I2C_interrupt\n");
}
